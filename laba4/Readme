## 1. Чим змінна відрізняється від масиву?
Змінна зберігає одне значення певного типу, тоді як масив є колекцією значень одного типу, що зберігаються в послідовних комірках пам'яті, доступ до яких здійснюється через індекси.

## 2. Що таке стек? Що таке купа? Яка між ними різниця?
- **Стек** — це структура даних, яка працює за принципом **LIFO** (останній прийшов — перший вийшов). Використовується для зберігання тимчасових змінних і виконання функцій.
- **Купа** — це область пам'яті для динамічних об'єктів, що створюються під час виконання програми, і де пам'ять виділяється за потребою. Тут немає принципу LIFO, і пам'ять вивільняється явно.

**Різниця**: Стек — швидший, але має обмежений розмір. Купа — більш гнучка, але з більшими витратами на управління пам'яттю.

## 3. Чи може змінна бути розташована у стеку? Безпосередньо у купі? В об’єкті у купі? Чи може масив бути розташований у стеку? Безпосередньо у купі? В об’єкті у купі?
- **Змінна** може бути розташована в **стеку** (локальні змінні).
- **Масив** зазвичай розташовується в **купі** (як динамічно виділений об'єкт), але може бути і в **стеку** (як локальний масив).
- Об'єкти, у тому числі масиви, можуть бути розташовані в **купі**.

## 4. Чим посилання на масив відрізняється від масиву? Чи може посилання на масив бути розташовано у стеку? Безпосередньо у купі? В об’єкті у купі?
- **Посилання на масив** є змінною, що зберігає адресу масиву в пам'яті. Воно відрізняється від самого масиву, оскільки не містить дані, а лише вказує на їх місце зберігання.
- **Посилання на масив** може бути розташоване в **стеку** (як локальна змінна), в **купі** (як частина об'єкта, що зберігає масив).

## 5. Якщо масив складається з 10 комірок, які індекси мають перша та остання комірки?
- Перша комірка має індекс **0**.
- Остання комірка має індекс **9** (якщо масив має 10 елементів).

## 6. Що буде, якщо звернутися до неіснуючої комірки у масиві?
Звернення до неіснуючої комірки викликає **помилку**: у Java це буде `ArrayIndexOutOfBoundsException`.

## 7. При створенні нового масиву без явної ініціалізації усі його комірки будуть проініціалізовані:
- Якщо масив створюється для примітивних типів, комірки ініціалізуються **спеціальними значеннями за замовчуванням** (наприклад, 0 для `int`, `false` для `boolean`).
- Якщо масив створюється для об'єктів, кожна комірка буде містити **`null`**.

## 8. Як дізнатися номер першої та останньої комірки масиву, якщо відомо лише посилання на нього?
- **Перша комірка** має індекс **0**.
- **Остання комірка** має індекс **масив.length - 1**.

## 9. Як змінити розмір масиву?
У Java неможливо змінити розмір масиву після його створення. Однак можна створити новий масив потрібного розміру і скопіювати дані зі старого масиву в новий.

## 10. Що відбувається з масивом при копіюванні посилання на нього?
При копіюванні посилання на масив обидва посилання будуть вказувати на той самий масив. Це означає, що зміни в одному масиві впливають на інший.

## 11. Що відбувається з масивом при втрачанні посилання на нього?
Коли посилання на масив втрачається, об'єкт масиву стає доступним для **сборщика сміття** (garbage collector), який може вивільнити пам'ять.

## 12. Чим відрізняються конструкції «for» та «for-each» при роботі з масивами? Які переваги та недоліки кожного з варіантів?
- **for**: Це класичний цикл, де ви маєте більше контролю над індексами та можете змінювати елементи масиву. Недоліком є більша складність.
- **for-each**: Це спрощений варіант циклу, що автоматично ітерує через елементи масиву. Він зручний для перебору без змін індексів, але не дозволяє змінювати масив чи використовувати індекси.

## 13. Чи можна у масив «double[]» записати значення «int»? Чи можна у масив «int[]» записати значення «double»?
- **double[]** може містити значення **int**, оскільки `int` можна автоматично привести до `double` (явне розширення типу).
- **int[]** не може містити значення **double**, оскільки `double` не може бути автоматично приведено до `int` (неявне звуження типу).
